package com.alice.test

import org.apache.spark.ml.clustering.{KMeans, KMeansModel}
import org.apache.spark.ml.feature.{MinMaxScaler, MinMaxScalerModel}
import org.apache.spark.sql.{DataFrame, SparkSession}

/*
用于实现  使用 kmeans 为鸢尾花数据分类
 */
object Iris {

  def main(args: Array[String]): Unit = {

    //1、创建sparlsession对象
    val spark: SparkSession = SparkSession.builder().appName("Iris").master("local[*]").getOrCreate()

    spark.sparkContext.setLogLevel("WARN")

    //2、读取libsvm 数据
    val irisLibSvmDF: DataFrame = spark.read.format("libsvm")
      .load("file:///E:\\2020大数据\\BigData\\企业级360°全方位用户画像【讲义】\\课堂资料\\0619\\03挖掘型标签\\数据集\\iris_kmeans.txt")
    irisLibSvmDF.show(false)

    /*
 +-----+-------------------------------+
|label|features                       |
+-----+-------------------------------+
|1.0  |(4,[0,1,2,3],[5.1,3.5,1.4,0.2])|
|1.0  |(4,[0,1,2,3],[4.9,3.0,1.4,0.2])|
|1.0  |(4,[0,1,2,3],[4.7,3.2,1.3,0.2])|
|1.0  |(4,[0,1,2,3],[4.6,3.1,1.5,0.2])|
|1.0  |(4,[0,1,2,3],[5.0,3.6,1.4,0.2])|
     */

    //3、数据归一化（将数据归一到0-1之间，计算速度快）
    //数据归一化
    //把数据映射到0～1范围之内处理，更加便捷快速
    //MinMaxScaler  把有量纲表达式变成无量纲表达式，便于不同单位或量级的指标能够进行比较和加权。
    //x' = (x - X_min) / (X_max - X_min)

    val scalerDatas: MinMaxScalerModel = new MinMaxScaler()
      .setInputCol("features") //设置需要归一化的列
      .setOutputCol("featuresOut") //归一化后的数据的列名字
      .fit(irisLibSvmDF) //设置数据


    val scalerDF: DataFrame = scalerDatas.transform(irisLibSvmDF)
    scalerDF.show(false)

/*
+-----+-------------------------------+---------------------------------------------------------------------------------+
|label|features                       |featuresOut                                                                      |
+-----+-------------------------------+---------------------------------------------------------------------------------+
|1.0  |(4,[0,1,2,3],[5.1,3.5,1.4,0.2])|[0.22222222222222213,0.6249999999999999,0.06779661016949151,0.04166666666666667] |
|1.0  |(4,[0,1,2,3],[4.9,3.0,1.4,0.2])|[0.1666666666666668,0.41666666666666663,0.06779661016949151,0.04166666666666667] |
|1.0  |(4,[0,1,2,3],[4.7,3.2,1.3,0.2])|[0.11111111111111119,0.5,0.05084745762711865,0.04166666666666667]                |
|1.0  |(4,[0,1,2,3],[4.6,3.1,1.5,0.2])|[0.08333333333333327,0.4583333333333333,0.0847457627118644,0.04166666666666667]  |
|1.0  |(4,[0,1,2,3],[5.0,3.6,1.4,0.2])|[0.19444444444444448,0.6666666666666666,0.06779661016949151,0.04166666666666667] |

 */

    //4、使用kmeans进行计算
    val prediction: KMeansModel = new KMeans()
      .setK(3) //设置需要划分类别的数量/个数
      .setMaxIter(10) //设置最大计算次数
      .setFeaturesCol("featuresOut") //设置特征的列    归一化后的列    /* 归一化能够加快KMeans计算的速度 */
      .setPredictionCol("predictionValue") //设置最终预测后的结果列名
      .setSeed(10) //设置随机种子
      .fit(scalerDF)


    val predictionDF: DataFrame = prediction.transform(scalerDF)
    predictionDF.show(false)
    /*
+-----+-------------------------------+---------------------------------------------------------------------------------+---------------+
|label|features                       |featuresOut                                                                      |predictionValue|
+-----+-------------------------------+---------------------------------------------------------------------------------+---------------+
|1.0  |(4,[0,1,2,3],[5.1,3.5,1.4,0.2])|[0.22222222222222213,0.6249999999999999,0.06779661016949151,0.04166666666666667] |0              |
|1.0  |(4,[0,1,2,3],[4.9,3.0,1.4,0.2])|[0.1666666666666668,0.41666666666666663,0.06779661016949151,0.04166666666666667] |0              |
|1.0  |(4,[0,1,2,3],[4.7,3.2,1.3,0.2])|[0.11111111111111119,0.5,0.05084745762711865,0.04166666666666667]                |0              |
|1.0  |(4,[0,1,2,3],[4.6,3.1,1.5,0.2])|[0.08333333333333327,0.4583333333333333,0.0847457627118644,0.04166666666666667]  |0              |
|1.0  |(4,[0,1,2,3],[5.0,3.6,1.4,0.2])|[0.19444444444444448,0.6666666666666666,0.06779661016949151,0.04166666666666667] |0              |
|1.0  |(4,[0,1,2,3],[5.4,3.9,1.7,0.4])|[0.30555555555555564,0.7916666666666665,0.11864406779661016,0.12500000000000003] |0              |
     */


    //简单验证
    predictionDF.groupBy("label","predictionValue").count().show()
  /*
+-----+---------------+-----+
|label|predictionValue|count|
+-----+---------------+-----+
|  2.0|              1|   47|
|  1.0|              0|   50|
|  2.0|              2|    3|
|  3.0|              1|   14|
|  3.0|              2|   36|
+-----+---------------+-----+

*/

  }
}
